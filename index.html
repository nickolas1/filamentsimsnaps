<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,300,600' rel='stylesheet' type='text/css'>
        <script type="text/javascript" src="js/jquery.min.js"></script>
        <script type="text/javascript" src="js/skel.min.js"></script>
        <script type="text/javascript" src="js/d3.v3.min.js"></script>
        <script type="text/javascript" src="js/skel.min.js">
        {
            prefix: "css/style",
            resetCSS: true,
            boxModel: "border",
            grid: { gutters: 0 },
            breakpoints: {
                wide: { range: "1500-", containers: 1596 },
                normal: { range: "1300-1500", containers: 1194 },
                narrow: { range: "-1299", containers: 799 }
            }
        }
        </script>
       
    </head>
    
    <body>
        <div id="main">
            <div class="container">
                <div class="row">
                    <div class="12u">
                        <div class="header">
                            <h1>Ceci n'est pas un real simulation</h1>
                            <p>test bed for giving collaborators an overview of a simulation</p>
                        </div>
                    </div>
                </div>
                <div class="row">
                    <div class="2u">
                        <div id="timenumber" class="time number">0.00</div>
                    </div>
                    <div class="1u">
                        <div id="timeunit" class="time unit">&nbsp;Myr</div>
                    </div>
                    <div id="timecontrol" class="8u"></div>
                </div>
                <div class="row">
                    <div class="3u">
                        <div class="description">
                        <p> This is a <em>ludicrously underresolved</em> simulation of about 400,000 Solar
                        masses of turbulent molecular gas collapsing. The base grid is 128 cubed; the gas is underresolved.
                        The sink particles are about half a parsec in radius; they are underresolved. Believe nothing.
                        <p>
                        </div>  
                    </div>
                    <div id="yz" class="4u"></div>
                    <div id="xz" class="4u"></div>
                    <div id="scalebar" class="1u"></div>
                </div>
                <div class="row">
                    <div id="sinkplot" class="-2u 5u"></div>
                    <div id="xy" class="4u"></div>
                </div>
            <div>
        </div>
    
        <script type="text/javascript">

        /* ========================== */
        /* get the size of the skelJS containers and set some other sizes*/
        var impanelsize = parseInt(d3.select("#yz").style("width"));
        var plpanelsize = parseInt(d3.select("#sinkplot").style("width"));
        var plleftmargin = plpanelsize - impanelsize;
        if (impanelsize < 300) { //narrow
            var immargin = {top: 5, right: 5, bottom: 5, left: 5}; // image margin
            var plmargin = {top: 5, right: 15, bottom: 15, left: plleftmargin}; // plot margin
            var slmargin = {top: 10, right: 50, bottom: 5, left: 50}; //slider margin
            var linewidth = ".5px";
            var ccfs = "9px"; //coordinate clue font size
            var axesfs = "9px";
            var sinksize = 2;
        }
        else if (impanelsize > 500){ //wide
            var immargin = {top: 10, right: 10, bottom: 10, left: 10};
            var plmargin = {top: 10, right: 20, bottom: 15, left: plleftmargin};
            var slmargin = {top: 10, right: 50, bottom: 5, left: 50}; //slider margin
            var linewidth = ".75px";
            var ccfs = "11px"; //coordinate clue font size
            var sinksize = 4;  
        }
        else { //normal
            var immargin = {top: 7, right: 7, bottom: 7, left: 7};
            var plmargin = {top: 7, right: 17, bottom: 15, left: plleftmargin};
            var slmargin = {top: 10, right: 50, bottom: 5, left: 50}; //slider margin
            var linewidth = ".75px";
            var ccfs = "12px"; //coordinate clue font size
            var sinksize = 3;    
        }
        var imsize = impanelsize - immargin.left - immargin.right; //image height and width
        var plw = plpanelsize - plmargin.left - plmargin.right;  //plot width
        var plh = impanelsize - plmargin.top - plmargin.bottom;  //plot height
        var slw = 2*impanelsize - slmargin.left - slmargin.right; //slider panel width
        var slh = impanelsize/4 - slmargin.top - slmargin.bottom; //slider panel height
        $("#timenumber").css("height", slh + "px");
        $("#timenumber").css("line-height", slh + "px");
        $("#timeunit").css("height", slh + "px");
        $("#timeunit").css("line-height", slh + "px");
        
        // this scale needs to be accessible to several plotting functions
        var sinkColorLo = "hsl(39, 43%, 70%)";
        var sinkColorHi = "hsl(13, 100%, 50%)";
        var sinkMLo = 0.5;
        var sinkMHi = 5000;
        var cScaleSink = d3.scale.log() // color scale for sink particles
                    .domain([sinkMLo, sinkMHi])
                    .range([sinkColorLo, sinkColorHi]).interpolate(d3.interpolateHsl); 
        
        
        //populatePanels(snap);
        
        
        /* ========================== */
        /* set up time control slider. */
        // follow http://bl.ocks.org/mbostock/6452972  
        // for styling and basic functionality 
        var timeSliderX = d3.scale.linear()
            .domain([0, 6])
            .range([0, slw])
            .clamp(true);
            
        var brush = d3.svg.brush()
            .x(timeSliderX)
            .extent([0, 0])
            .on("brush", brushed2);
            
        var timeslider = d3.select("#timecontrol").append("svg")
            .attr("width", slw + slmargin.left + slmargin.right)
            .attr("height", slh + slmargin.top + slmargin.bottom)
            .append("g")
            .attr("transform", "translate(" + slmargin.left + "," + slmargin.top + ")");
        
        timeslider.append("g")
            .attr("class", "sl axis")
            .attr("transform", "translate(0," + slh / 2 + ")")
            .call(d3.svg.axis()
                .scale(timeSliderX)
                .orient("bottom")
                .ticks(3)
                .tickFormat(function(d) { return d + " Myr"}))
            .select("domain")
            .select(function() { return this.parentNode.appendChild(this.cloneNode(true)); })
                .attr("class", "halo")
                
        var slider = timeslider.append("g")
            .attr("class", "slider")
            .call(brush);
            
       // slider.selectAll(".extent, .resize")
       //     .remove();
        
        slider.select(".background")
            .attr("height", slh)
            
        var handle = slider.append("circle")
            .attr("class", "handle")
            .attr("transform", "translate(0," + slh / 2 + ")")
            .attr("r", 7);
       
        var myrFormat = d3.format(".2f");
        var snapStep =  0.074537;
        var snap; // the output number the slider selects
        var snapTime = function(num) { // round to a snapshot time
           // console.log(Math.floor((num / snapStep) + 0.5) * snapStep);
            return Math.floor((num / snapStep) + 0.5) * snapStep;
        }
        function brushed() { //allow any value
          var value = brush.extent()[0];
          if (d3.event.sourceEvent) { // not a programmatic event
            value = timeSliderX.invert(d3.mouse(this)[0]);
            brush.extent([value, value]);       
          }
          handle.attr("cx", timeSliderX(value));
          d3.select("#timenumber").text(myrFormat(value))
        };
        function brushed2() {// only allow values with a snapshot
          var desiredTime = brush.extent()[0];
          if (d3.event.sourceEvent) { // not a programmatic event
            desiredTime = timeSliderX.invert(d3.mouse(this)[0]);
            snappedTime = snapTime(desiredTime);
            snap = Math.round(snappedTime / snapStep + 1);
            if (snap > 80) {
                snap = 80;
                snappedTime = (80 - 1) * snapStep;
            };
            brush.extent([snappedTime, snappedTime]);
          }
          handle.attr("cx", timeSliderX(snappedTime));
          d3.select("#timenumber").text(myrFormat(snappedTime));
          populatePanels(snap);
        };


        /* ========================== */
        /* set up svg panels to show images and sink particles */
        var axesData = [{"x": 0.03*imsize, "y": 0.87 * imsize},
                            {"x": 0.03*imsize, "y": 0.97 * imsize},
                            {"x": 0.13*imsize, "y": 0.97 * imsize}];
        var scaleBarData = [{"x": 0.03*imsize, "y": 0.879 * imsize},
                                {"x": 0.03*imsize, "y": 0.121 * imsize}];
        var lineFunction = d3.svg.line()
                                .x(function(d) { return d.x; })
                                .y(function(d) { return d.y; })
                                .interpolate("linear");
        var showAxesLabels = function(projection, xlabel, ylabel) {
            projection.append("path")
                .attr("d", lineFunction(axesData))
                .attr("stroke", "hsl(188,100%, 24%)")
                .attr("stroke-width", linewidth)
                .attr("stroke-opacity", 0.3)
                .attr("shape-rendering", "crispEdges")
                .attr("fill", "none");
            projection.append("text")
                .attr("x", 0.15 * imsize)
                .attr("y", 0.97 * imsize)
                .attr("font-size", ccfs)
                .attr("class", "coordclue")
                .attr("dy", "0.2em")
                .text(xlabel);
            projection.append("text")
                .attr("x", 0.03 * imsize)
                .attr("y", 0.85 * imsize)
                .attr("font-size", ccfs)
                .attr("class", "coordclue")
                .text(ylabel);
        };
        // show a scale bar
        var scalepanel = d3.select("#scalebar").append("svg")
            .attr("width", impanelsize/4)
            .attr("height", impanelsize);
        scalepanel.append("g")
            .attr("width",imsize/4)
            .attr("height", imsize)
            .append("path")
                .attr("d", lineFunction(scaleBarData))
                .attr("stroke", "hsl(188,100%, 24%)")
                .attr("stroke-width", linewidth)
                .attr("stroke-opacity", 0.3)
                .attr("shape-rendering", "crispEdges")
                .attr("fill", "none");
        scalepanel.append("text")
            .attr("x", 0.1 * imsize)
            .attr("y", 0.5 * imsize)
            .attr("font-size", ccfs)
            .attr("class", "coordclue")
            .text("50 pc");
            
        var panel0 = d3.select("#yz").append("svg")
                .attr("width", impanelsize)
                .attr("height", impanelsize);
        var panel1 = d3.select("#xz").append("svg")
                .attr("width", impanelsize)
                .attr("height", impanelsize);
        var panel2 = d3.select("#xy").append("svg")
                .attr("width", impanelsize)
                .attr("height", impanelsize);
        /* set up padded image display areas */        
        var proj0 = panel0.append("g")
                .attr("width", imsize)
                .attr("height", imsize)
                .attr("transform", "translate(" + immargin.left + "," + immargin.top + ")");
        var proj0image = proj0.append("image")
                .attr("width", imsize)
                .attr("height", imsize);
        showAxesLabels(proj0, "y", "z");
        var proj1 = panel1.append("g")
                .attr("width", imsize)
                .attr("height", imsize)
                .attr("transform", "translate(" + immargin.left + "," + immargin.top + ")");
        var proj1image = proj1.append("image")
                .attr("width", imsize)
                .attr("height", imsize);
        showAxesLabels(proj1, "x", "z");       
        var proj2 = panel2.append("g")
                .attr("width", imsize)
                .attr("height", imsize)
                .attr("transform", "translate(" + immargin.left + "," + immargin.top + ")");
        var proj2image = proj2.append("image")
                .attr("width", imsize)
                .attr("height", imsize);
        showAxesLabels(proj2, "x", "y");
        var showSurfaceDensityImages = function() {
            /* ========================== */
            /* display the images */
            proj0image.attr("xlink:href", fImage0); 
            proj1image.attr("xlink:href", fImage1); 
            proj2image.attr("xlink:href", fImage2);    
        }; 
        
         /* ========================== */
        /* plot sink masses*/
        var plotpanel = d3.select("#sinkplot").append("svg")
                .attr("width", plpanelsize)
                .attr("height", plpanelsize);
        /* set up padded image display areas */        
        var sinkplot = plotpanel.append("g")
                .attr("width", plw)
                .attr("height", plh)
                .attr("transform", "translate(" + plmargin.left + "," + plmargin.top + ")");

        var sinkdata;
        var xScaleTime = d3.scale.linear();
        var yScaleMass = d3.scale.log().clamp(true);
        d3.json("data/sinks/sinkmasses.json", function(indata) {
            sinkdata = indata;
            xScaleTime.domain([0, d3.max(sinkdata, function(dd) { return d3.max(dd.data, function(d) { return d.time;}) })])
                .range([0, plw])
                .nice();
            yScaleMass.domain([sinkMLo, sinkMHi])
                .range([plh, 0]);
            plotSinkMasses();
            scatterSinkMasses();
        });
        
        
        var plotSinkMasses = function() {              
            var myrFormat = d3.format(",f Myr");    
            var sinkXAxis = d3.svg.axis()
                .scale(xScaleTime)
                .orient("bottom")
                .ticks(4)
                .tickFormat(function(d) { return d + " Myr"});
            
            var numberFormat = d3.format(",g");
            function sparseLogFormat(d) {
                var x = Math.log(d) / Math.log(10) + 1e-6;
                return Math.abs(x - Math.floor(x)) < .3 ? numberFormat(d) : "";
            }
            
            var sinkYAxis = d3.svg.axis()
                .scale(yScaleMass)
                .orient("left")
                .tickFormat(sparseLogFormat);
                
            var sinkLine = d3.svg.line()
                .interpolate("linear")
                .x(function(d) { return xScaleTime(d.time); })
                .y(function(d) { return yScaleMass(d.mass); });
            
            var sink = sinkplot.selectAll(".sink")
                .data(sinkdata)
                .enter().append("g")
                .attr("class", "sink");
                
            // make a hidden gradient
            sink.append("linearGradient")                
                    .attr("id", "sinkLineGradient")            
                    .attr("gradientUnits", "userSpaceOnUse")    
                    .attr("x1", 0).attr("y1", yScaleMass(sinkMLo))         
                    .attr("x2", 0).attr("y2", yScaleMass(sinkMHi))      
                .selectAll("stop")                      
                    .data([                             
                        {offset: "0%", color: sinkColorLo},          
                        {offset: "100%", color: sinkColorHi}    
                    ])                  
                .enter().append("stop")         
                    .attr("offset", function(d) { return d.offset; })   
                    .attr("stop-color", function(d) { return d.color; });   
            
            sink.append("path")
                .attr("class", "sinkline")
                .attr("d", function(d) {return sinkLine(d.data); });
            
            sinkplot.append("g")
                .attr("transform", "translate(0," + plh + ")") 
                .attr("class", "x axis")
                .call(sinkXAxis);
            
            sinkplot.append("g") 
                .attr("class", "y axis")
                .call(sinkYAxis);
                
           /* sinkplot.append("text")
                .attr("x", 0.5*plw)
                .attr("y", plh + 5*plmargin.top)
                .attr("text-anchor", "middle")
                .attr("class", "axislabel")
                .text("time / Myr");*/
                
            sinkplot.append("text")
                //.attr("transform", "rotate(-90)")
                //.attr("x", -0.5*plh)
                //.attr("y", -8*plmargin.right)
                .attr("x", 0.5*plmargin.right)
                .attr("y", 1.6*plmargin.top)
                //.attr("text-anchor", "middle")
                .attr("class", "axislabel")
                .text("sink mass / Solar");       
        }; 
          
          
        /* ========================== */
        /* plot sinks */
        var showSinkParticles = function() {
            var sinkdata = [{}];   
            //d3.text(fSinks, function(text) {
            console.log(sinkdata);
            d3.text(fSinks, function(text) {
                console.log(text!=null);
                if (text!= null) {
                    sinkdata = d3.csv.parseRows(text).map(function(row) {
                        return {
                            id: +row[0],
                            m: +row[1],
                            x: +row[2],
                            y: +row[3],
                            z: +row[4]
                        };
                    /*return row.map(function(value) {
                        return +value;
                    });*/
                    });
                    scatterSinks();
                }
                else {
                    // if no sinks now, clear all sink markers
                    proj0.selectAll("circle").attr("visibility", "hidden");
                    proj1.selectAll("circle").attr("visibility", "hidden");
                    proj2.selectAll("circle").attr("visibility", "hidden");
                    sinkplot.selectAll("circle").attr("visibility", "hidden");
                };
            });
            
            
            var scatterSinks = function() { 
                var xScaleIm = d3.scale.linear()
                    .domain([0, 6.6666])
                    .range([0, imsize]);
                var yScaleIm = d3.scale.linear()
                    .domain([0, 6.6666])
                    .range([imsize, 0]); 
                     
                var circles0 = proj0.selectAll("circle")
                    .data(sinkdata);
                // update positions and colors
                circles0.attr("cx", function(d) { return xScaleIm(d.y) })
                    .attr("visibility", "visible")
                    .attr("cy", function(d) { return yScaleIm(d.z) })
                    .attr("fill", function(d) {return cScaleSink(d.m) });
                // add new sinks
                circles0.enter().append("svg:circle")
                    .attr("cx", function(d) { return xScaleIm(d.y) })
                    .attr("cy", function(d) { return yScaleIm(d.z) })
                    .attr("stroke-width", "none")
                    .attr("fill", function(d) {return cScaleSink(d.m) })
                    .attr("r", sinksize);       
                // destroy merged sinks    
                circles0.exit().remove();
                
                var circles1 = proj1.selectAll("circle")
                    .data(sinkdata);
                circles1.attr("cx", function(d) { return xScaleIm(d.x) })
                    .attr("visibility", "visible")
                    .attr("cy", function(d) { return yScaleIm(d.z) })
                    .attr("fill", function(d) {return cScaleSink(d.m) });
                circles1.enter().append("svg:circle")
                    .attr("cx", function(d) { return xScaleIm(d.x) })
                    .attr("cy", function(d) { return yScaleIm(d.z) })
                    .attr("stroke-width", "none")
                    .attr("fill", function(d) {return cScaleSink(d.m) })
                    .attr("r", sinksize);        
                circles1.exit().remove();
                
                var circles2 = proj2.selectAll("circle")
                    .data(sinkdata);
                circles2.attr("cx", function(d) { return xScaleIm(d.x) })
                    .attr("cy", function(d) { return yScaleIm(d.y) })
                    .attr("fill", function(d) {return cScaleSink(d.m) });
                circles2.enter().append("svg:circle")
                    .attr("visibility", "visible")
                    .attr("cx", function(d) { return xScaleIm(d.x) })
                    .attr("cy", function(d) { return yScaleIm(d.y) })
                    .attr("stroke-width", "none")
                    .attr("fill", function(d) {return cScaleSink(d.m) })
                    .attr("r", sinksize);        
                circles2.exit().remove();
                
                scatterSinkMasses(sinkdata);
             };  
        };
        
        
        var scatterSinkMasses = function(sinkdata) {
            var timeNow = (snap - 1) * snapStep;
            var circles3 = sinkplot.selectAll("circle")
                    .data(sinkdata);
                circles3.attr("cx", function(d) { return xScaleTime(timeNow) })
                    .attr("visibility", "visible")
                    .attr("cy", function(d) { return yScaleMass(d.m) })
                    .attr("fill", function(d) {return cScaleSink(d.m) });
                circles3.enter().append("svg:circle")
                    .attr("cx", function(d) { return xScaleTime(timeNow) })
                    .attr("cy", function(d) { return yScaleMass(d.m) })
                    .attr("stroke-width", "none")
                    .attr("fill", function(d) {return cScaleSink(d.m) })
                    .attr("r", sinksize*1.5);        
                circles3.exit().remove();
        };
        
            
          
        /* ========================== */
        /* start out at t = 0 */
        var snap = 1;
        var fImage0,
            fImage1,
            fImage2,
            fSinks;
        var getFileNames = function(snap) {
            var zeroPad = d3.format("05d");
            snapPad = zeroPad(snap);
            fImage0 = "data/images/surfacedensity0/sd0_frame_" + snapPad + ".jpeg";
            fImage1 = "data/images/surfacedensity1/sd1_frame_" + snapPad + ".jpeg";
            fImage2 = "data/images/surfacedensity2/sd2_frame_" + snapPad + ".jpeg";
            fSinks = "data/sinks/sink_" + snapPad + ".csv";
        }
        var populatePanels = function(snap) {
            getFileNames(snap);
            showSurfaceDensityImages();
            showSinkParticles();
        }
        populatePanels(snap);  
            

        </script>
        

    </body>
</html>